{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"quickhttp quickhttp is a lightweight CLI that wraps Python's http.server with automatic port-finding and automatic shutdown after a configurable idle duration. Features Automatically finds and uses an available port. Has a keep-alive time after which it will shut down automatically if no requests are received, in case you forget about it. More secure default of 127.0.0.1 ( localhost ) instead of 0.0.0.0 . Easier to type and autocomplete than python -m http.server . Installation You can get quickhttp from PyPI . I recommend using pipx to manage Python command-line programs: pipx install quickhttp You can also install normally using regular pip : pip install quickhttp Requires Python 3.6 or higher. Development Version To install the development version of this program, get it directly from GitHub. pipx install git+https://github.com/jayqi/quickhttp.git Documentation quickhttp --help Usage: quickhttp [OPTIONS] [DIRECTORY] Lightweight CLI that wraps Python's `http.server` with automatic port- finding and shutdown. Arguments: [DIRECTORY] Directory to serve. [default: .] Options: -t, --timeout TEXT Time to keep server alive for after most recent request. Accepts time expressions parsable by pytime parse, such as '10m' or '10:00'. [default: 10m] -b, --bind TEXT Address to bind server to. '127.0.0.1' (or 'localhost') will only be accessible from this computer. '0.0.0.0' is all interfaces (IP addresses) on this computer, meaning that it can be accessible by other computers at your IP address. [default: 127.0.0.1] -p, --port INTEGER Port to use. If None (default), will automatically search for an open port using the other port-related options. If specified, ignores other port-related options. --port-range-min INTEGER Minimum of range to search for an open port. [default: 8000] --port-range-max INTEGER Maximum of range to search for an open port. [default: 8999] --port-max-tries INTEGER Maximum number of ports to check. [default: 50] --port-search-type [sequential|random] Type of search to use. [default: sequential] --version Show version and exit. --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Why use quickhttp ? python -m http.server is a pain to type. quickhttp is shorter and can autocomplete. (But you can still do python -m quickhttp too if you really want to.) If you try starting python -m http.server and port 8000 is unavailable, you get OSError: [Errno 48] Address already in use . Then you have to choose another port and try again. quickhttp deals with ports automatically for you. quickhttp will automatically shutdown after the keep-alive time expires. This defaults to 10 minutes. I often start up an HTTP server to look at something, then open a new tab to continue doing things, and then I forget about the server. python -m http.server defaults to 0.0.0.0, which makes your server accessible to other people at your computer's IP address. This is a security vulnerability, but isn't necessarily obvious to people who just want to quickly serve some static files.","title":"Home"},{"location":"#quickhttp","text":"quickhttp is a lightweight CLI that wraps Python's http.server with automatic port-finding and automatic shutdown after a configurable idle duration.","title":"quickhttp"},{"location":"#features","text":"Automatically finds and uses an available port. Has a keep-alive time after which it will shut down automatically if no requests are received, in case you forget about it. More secure default of 127.0.0.1 ( localhost ) instead of 0.0.0.0 . Easier to type and autocomplete than python -m http.server .","title":"Features"},{"location":"#installation","text":"You can get quickhttp from PyPI . I recommend using pipx to manage Python command-line programs: pipx install quickhttp You can also install normally using regular pip : pip install quickhttp Requires Python 3.6 or higher.","title":"Installation"},{"location":"#development-version","text":"To install the development version of this program, get it directly from GitHub. pipx install git+https://github.com/jayqi/quickhttp.git","title":"Development Version"},{"location":"#documentation","text":"quickhttp --help Usage: quickhttp [OPTIONS] [DIRECTORY] Lightweight CLI that wraps Python's `http.server` with automatic port- finding and shutdown. Arguments: [DIRECTORY] Directory to serve. [default: .] Options: -t, --timeout TEXT Time to keep server alive for after most recent request. Accepts time expressions parsable by pytime parse, such as '10m' or '10:00'. [default: 10m] -b, --bind TEXT Address to bind server to. '127.0.0.1' (or 'localhost') will only be accessible from this computer. '0.0.0.0' is all interfaces (IP addresses) on this computer, meaning that it can be accessible by other computers at your IP address. [default: 127.0.0.1] -p, --port INTEGER Port to use. If None (default), will automatically search for an open port using the other port-related options. If specified, ignores other port-related options. --port-range-min INTEGER Minimum of range to search for an open port. [default: 8000] --port-range-max INTEGER Maximum of range to search for an open port. [default: 8999] --port-max-tries INTEGER Maximum number of ports to check. [default: 50] --port-search-type [sequential|random] Type of search to use. [default: sequential] --version Show version and exit. --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit.","title":"Documentation"},{"location":"#why-use-quickhttp","text":"python -m http.server is a pain to type. quickhttp is shorter and can autocomplete. (But you can still do python -m quickhttp too if you really want to.) If you try starting python -m http.server and port 8000 is unavailable, you get OSError: [Errno 48] Address already in use . Then you have to choose another port and try again. quickhttp deals with ports automatically for you. quickhttp will automatically shutdown after the keep-alive time expires. This defaults to 10 minutes. I often start up an HTTP server to look at something, then open a new tab to continue doing things, and then I forget about the server. python -m http.server defaults to 0.0.0.0, which makes your server accessible to other people at your computer's IP address. This is a security vulnerability, but isn't necessarily obvious to people who just want to quickly serve some static files.","title":"Why use quickhttp?"},{"location":"api-reference/","text":"API Reference Documentation for quickhttp.core module. DirectoryHTTPRequestHandler Subclass of http.server.SimpleHTTPRequestHandler that accepts a directory. Necessary because Python 3.6 doesn't support the directory argument added in Python 3.7. translate_path ( self , path ) Translate a /-separated PATH to the local filename syntax. Components that mean special things to the local file system (e.g. drive or directory names) are ignored. (XXX They should probably be diagnosed.) Source code in quickhttp/core.py 144 145 146 147 def translate_path ( self , path ): path = super () . translate_path ( path ) rel_path = Path ( path ) . relative_to ( Path . cwd ()) return self . directory / rel_path SearchType Available types of search for [find_available_port][quickhttp.core.find_available_port] Attributes: Name Type Description sequential Search ports sequentially, starting with range_min. random Search ports randomly within [range_min, range_max]. TimedHTTPServer Subclass of http.server.HTTPServer that tracks timeout status. handle_timeout ( self ) Called if no new request arrives within self.timeout. Overridden by ForkingMixIn. Source code in quickhttp/core.py 131 132 def handle_timeout ( self ): self . timeout_reached = True find_available_port ( range_min = 8000 , range_max = 8999 , max_tries = 50 , search_type =< SearchType . sequential : 'sequential' > ) Searches for an available port (not in use) on the local host. Parameters: Name Type Description Default range_min int Minimum of range to search. Defaults to 8000. 8000 range_max int Maximum of range to search. Defaults to 8999. 8999 max_tries int Maximum number of ports to check. Defaults to 50. 50 search_type SearchType Type of search. One of [sequential|random]. Defaults to sequential. <SearchType.sequential: 'sequential'> Exceptions: Type Description ValueError If search_type is invalid. NoAvailablePortFound If no available ports found within max_tries. Returns: Type Description int int: An available port Source code in quickhttp/core.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def find_available_port ( range_min : int = DEFAULT_PORT_RANGE_MIN , range_max : int = DEFAULT_PORT_RANGE_MAX , max_tries : int = DEFAULT_PORT_MAX_TRIES , search_type : SearchType = DEFAULT_PORT_SEARCH_TYPE , ) -> int : max_tries = min ( max_tries , range_max - range_min + 1 ) to_try : Iterable [ int ] if search_type == SearchType . sequential : to_try = islice ( range ( range_min , range_max + 1 ), max_tries ) elif search_type == SearchType . random : to_try = random . sample ( range ( range_min , range_max + 1 ), max_tries ) else : msg = ( f \"Invalid search_type { search_type } . Available options are \" f \"[ { '|' . join ( level . value for level in SearchType ) } ].\" ) raise ValueError ( msg ) for port in to_try : if is_port_available ( port = port ): return port raise NoAvailablePortFound ( f \"Unable to find available port in range [ { range_min } , { range_max } ] with \" f \" { SearchType ( search_type ) . value } search in { max_tries } tries.\" ) is_port_available ( port ) Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Parameters: Name Type Description Default port int port to check. required Returns: Type Description bool bool: If that port is available (not in use). Source code in quickhttp/core.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def is_port_available ( port : int ) -> bool : \"\"\"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Args: port (int): port to check. Returns: bool: If that port is available (not in use). \"\"\" with closing ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM )) as sock : if sock . connect_ex (( \"127.0.0.1\" , port )) == 0 : # Successfull connection return False return True run_timed_http_server ( address , port , directory , timeout ) Start a HTTPServer with specified timeout. Parameters: Name Type Description Default address str Address to bind the server to. required port int Port to use. required directory Union[str, os.PathLike] Directory to serve. required timeout int Time to keep server alive for, in seconds. required Source code in quickhttp/core.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def run_timed_http_server ( address : str , port : int , directory : Union [ str , os . PathLike ], timeout : int ): \"\"\"Start a [HTTPServer](https://docs.python.org/3/library/http.server.html) with specified timeout. Args: address (str): Address to bind the server to. port (int): Port to use. directory (Union[str, os.PathLike]): Directory to serve. timeout (int): Time to keep server alive for, in seconds. \"\"\" if sys . version_info [: 2 ] == ( 3 , 6 ): handler = partial ( DirectoryHTTPRequestHandler , directory = str ( directory )) else : handler = partial ( SimpleHTTPRequestHandler , directory = str ( directory )) with TimedHTTPServer ( server_address = ( address , port ), RequestHandlerClass = handler , timeout = timeout ) as httpd : try : while not httpd . timeout_reached : # type: ignore httpd . handle_request () typer . echo ( \"Timeout reached.\" ) except KeyboardInterrupt : typer . echo ( \" KeyboardInterrupt received.\" )","title":"API Reference"},{"location":"api-reference/#api-reference","text":"Documentation for quickhttp.core module.","title":"API Reference"},{"location":"api-reference/#quickhttp.core.DirectoryHTTPRequestHandler","text":"Subclass of http.server.SimpleHTTPRequestHandler that accepts a directory. Necessary because Python 3.6 doesn't support the directory argument added in Python 3.7.","title":"DirectoryHTTPRequestHandler"},{"location":"api-reference/#quickhttp.core.DirectoryHTTPRequestHandler.translate_path","text":"Translate a /-separated PATH to the local filename syntax. Components that mean special things to the local file system (e.g. drive or directory names) are ignored. (XXX They should probably be diagnosed.) Source code in quickhttp/core.py 144 145 146 147 def translate_path ( self , path ): path = super () . translate_path ( path ) rel_path = Path ( path ) . relative_to ( Path . cwd ()) return self . directory / rel_path","title":"translate_path()"},{"location":"api-reference/#quickhttp.core.SearchType","text":"Available types of search for [find_available_port][quickhttp.core.find_available_port] Attributes: Name Type Description sequential Search ports sequentially, starting with range_min. random Search ports randomly within [range_min, range_max].","title":"SearchType"},{"location":"api-reference/#quickhttp.core.TimedHTTPServer","text":"Subclass of http.server.HTTPServer that tracks timeout status.","title":"TimedHTTPServer"},{"location":"api-reference/#quickhttp.core.TimedHTTPServer.handle_timeout","text":"Called if no new request arrives within self.timeout. Overridden by ForkingMixIn. Source code in quickhttp/core.py 131 132 def handle_timeout ( self ): self . timeout_reached = True","title":"handle_timeout()"},{"location":"api-reference/#quickhttp.core.find_available_port","text":"Searches for an available port (not in use) on the local host. Parameters: Name Type Description Default range_min int Minimum of range to search. Defaults to 8000. 8000 range_max int Maximum of range to search. Defaults to 8999. 8999 max_tries int Maximum number of ports to check. Defaults to 50. 50 search_type SearchType Type of search. One of [sequential|random]. Defaults to sequential. <SearchType.sequential: 'sequential'> Exceptions: Type Description ValueError If search_type is invalid. NoAvailablePortFound If no available ports found within max_tries. Returns: Type Description int int: An available port Source code in quickhttp/core.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def find_available_port ( range_min : int = DEFAULT_PORT_RANGE_MIN , range_max : int = DEFAULT_PORT_RANGE_MAX , max_tries : int = DEFAULT_PORT_MAX_TRIES , search_type : SearchType = DEFAULT_PORT_SEARCH_TYPE , ) -> int : max_tries = min ( max_tries , range_max - range_min + 1 ) to_try : Iterable [ int ] if search_type == SearchType . sequential : to_try = islice ( range ( range_min , range_max + 1 ), max_tries ) elif search_type == SearchType . random : to_try = random . sample ( range ( range_min , range_max + 1 ), max_tries ) else : msg = ( f \"Invalid search_type { search_type } . Available options are \" f \"[ { '|' . join ( level . value for level in SearchType ) } ].\" ) raise ValueError ( msg ) for port in to_try : if is_port_available ( port = port ): return port raise NoAvailablePortFound ( f \"Unable to find available port in range [ { range_min } , { range_max } ] with \" f \" { SearchType ( search_type ) . value } search in { max_tries } tries.\" )","title":"find_available_port()"},{"location":"api-reference/#quickhttp.core.is_port_available","text":"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Parameters: Name Type Description Default port int port to check. required Returns: Type Description bool bool: If that port is available (not in use). Source code in quickhttp/core.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def is_port_available ( port : int ) -> bool : \"\"\"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Args: port (int): port to check. Returns: bool: If that port is available (not in use). \"\"\" with closing ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM )) as sock : if sock . connect_ex (( \"127.0.0.1\" , port )) == 0 : # Successfull connection return False return True","title":"is_port_available()"},{"location":"api-reference/#quickhttp.core.run_timed_http_server","text":"Start a HTTPServer with specified timeout. Parameters: Name Type Description Default address str Address to bind the server to. required port int Port to use. required directory Union[str, os.PathLike] Directory to serve. required timeout int Time to keep server alive for, in seconds. required Source code in quickhttp/core.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def run_timed_http_server ( address : str , port : int , directory : Union [ str , os . PathLike ], timeout : int ): \"\"\"Start a [HTTPServer](https://docs.python.org/3/library/http.server.html) with specified timeout. Args: address (str): Address to bind the server to. port (int): Port to use. directory (Union[str, os.PathLike]): Directory to serve. timeout (int): Time to keep server alive for, in seconds. \"\"\" if sys . version_info [: 2 ] == ( 3 , 6 ): handler = partial ( DirectoryHTTPRequestHandler , directory = str ( directory )) else : handler = partial ( SimpleHTTPRequestHandler , directory = str ( directory )) with TimedHTTPServer ( server_address = ( address , port ), RequestHandlerClass = handler , timeout = timeout ) as httpd : try : while not httpd . timeout_reached : # type: ignore httpd . handle_request () typer . echo ( \"Timeout reached.\" ) except KeyboardInterrupt : typer . echo ( \" KeyboardInterrupt received.\" )","title":"run_timed_http_server()"}]}