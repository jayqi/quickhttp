{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"quickhttp quickhttp is a lightweight CLI that wraps Python's http.server with automatic port-finding and automatic shutdown after a certain duration. Features Automatically finds and uses an available port. Has a keep-alive time and shuts down automatically, in case you forget about it. More secure default of 127.0.0.1 ( localhost ) instead of 0.0.0.0 . Easier to type and autocomplete than python -m http.server . Installation You can get quickhttp from PyPI . I recommend using pipx to manage Python command-line programs: pipx install quickhttp You can also install normally using regular pip : pip install quickhttp Requires Python 3.6 or higher. Development Version To install the development version of this program, get it directly from GitHub. pipx install git+https://github.com/jayqi/quickhttp.git Documentation quickhttp --help Usage: quickhttp [OPTIONS] [DIRECTORY] Lightweight CLI that wraps Python's `http.server` with automatic port- finding and shutdown. Arguments: [DIRECTORY] Directory to serve. [default: .] Options: -t, --time TEXT Time to keep server alive for. Accepts time expressions parsable by pytimeparse, such as '10m' or '10:00'. [default: 10m] -b, --bind TEXT Address to bind server to. '127.0.0.1' (or 'localhost') will only be accessible from this computer. '0.0.0.0' is all interfaces (IP addresses) on this computer, meaning that it can be accessible by other computers at your IP address. [default: 127.0.0.1] -p, --port INTEGER Port to use. If None (default), will automatically search for an open port using the other port-related options. If specified, ignores other port-related options. --port-range-min INTEGER Minimum of range to search for an open port. [default: 8000] --port-range-max INTEGER Maximum of range to search for an open port. [default: 8999] --port-max-tries INTEGER Maximum number of ports to check. [default: 50] --port-search-type [sequential|random] Type of search to use. [default: sequential] --version Show version and exit. --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Why use quickhttp ? python -m http.server is a pain to type. quickhttp is shorter and can autocomplete. (But you can still do pythom -m quickhttp too if you really want to.) If you try starting python -m http.server and port 8000 is unavailable, you get OSError: [Errno 48] Address already in use . Then you have to choose another port and try again. quickhttp deals with ports automatically for you. quickhttp will automatically shutdown after the keep-alive time expires. This defaults to 10 minutes. I often will start up an HTTP server to look at something, and then I open a new tab to continue doing things, and then I forget about the server. python -m http.server defaults to 0.0.0.0, which makes your server accessible to other people at your computer's IP address. This is a security vulnerability, but isn't obvious to people who don't know about 0.0.0.0 and 127.0.0.1.","title":"Home"},{"location":"#quickhttp","text":"quickhttp is a lightweight CLI that wraps Python's http.server with automatic port-finding and automatic shutdown after a certain duration.","title":"quickhttp"},{"location":"#features","text":"Automatically finds and uses an available port. Has a keep-alive time and shuts down automatically, in case you forget about it. More secure default of 127.0.0.1 ( localhost ) instead of 0.0.0.0 . Easier to type and autocomplete than python -m http.server .","title":"Features"},{"location":"#installation","text":"You can get quickhttp from PyPI . I recommend using pipx to manage Python command-line programs: pipx install quickhttp You can also install normally using regular pip : pip install quickhttp Requires Python 3.6 or higher.","title":"Installation"},{"location":"#development-version","text":"To install the development version of this program, get it directly from GitHub. pipx install git+https://github.com/jayqi/quickhttp.git","title":"Development Version"},{"location":"#documentation","text":"quickhttp --help Usage: quickhttp [OPTIONS] [DIRECTORY] Lightweight CLI that wraps Python's `http.server` with automatic port- finding and shutdown. Arguments: [DIRECTORY] Directory to serve. [default: .] Options: -t, --time TEXT Time to keep server alive for. Accepts time expressions parsable by pytimeparse, such as '10m' or '10:00'. [default: 10m] -b, --bind TEXT Address to bind server to. '127.0.0.1' (or 'localhost') will only be accessible from this computer. '0.0.0.0' is all interfaces (IP addresses) on this computer, meaning that it can be accessible by other computers at your IP address. [default: 127.0.0.1] -p, --port INTEGER Port to use. If None (default), will automatically search for an open port using the other port-related options. If specified, ignores other port-related options. --port-range-min INTEGER Minimum of range to search for an open port. [default: 8000] --port-range-max INTEGER Maximum of range to search for an open port. [default: 8999] --port-max-tries INTEGER Maximum number of ports to check. [default: 50] --port-search-type [sequential|random] Type of search to use. [default: sequential] --version Show version and exit. --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit.","title":"Documentation"},{"location":"#why-use-quickhttp","text":"python -m http.server is a pain to type. quickhttp is shorter and can autocomplete. (But you can still do pythom -m quickhttp too if you really want to.) If you try starting python -m http.server and port 8000 is unavailable, you get OSError: [Errno 48] Address already in use . Then you have to choose another port and try again. quickhttp deals with ports automatically for you. quickhttp will automatically shutdown after the keep-alive time expires. This defaults to 10 minutes. I often will start up an HTTP server to look at something, and then I open a new tab to continue doing things, and then I forget about the server. python -m http.server defaults to 0.0.0.0, which makes your server accessible to other people at your computer's IP address. This is a security vulnerability, but isn't obvious to people who don't know about 0.0.0.0 and 127.0.0.1.","title":"Why use quickhttp?"},{"location":"api-reference/","text":"API Reference Documentation for quickhttp.core module. SearchType Available types of search for [find_available_port][quickhttp.core.find_available_port] Attributes: sequential: Search ports sequentially, starting with range_min. random: Search ports randomly within [range_min, range_max]. find_available_port ( range_min = 8000 , range_max = 8999 , max_tries = 50 , search_type = 'sequential' ) Searches for an available port (not in use) on the local host. Parameters: Name Type Description Default range_min int Minimum of range to search. Defaults to 8000. 8000 range_max int Maximum of range to search. Defaults to 8999. 8999 max_tries int Maximum number of ports to check. Defaults to 50. 50 search_type SearchType Type of search. One of [sequential|random]. Defaults to sequential. 'sequential' Exceptions: Type Description ValueError If search_type is invalid. NoAvailablePortFound If no available ports found within max_tries. Returns: Type Description int int: An available port Source code in quickhttp/core.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def find_available_port ( range_min : int = DEFAULT_PORT_RANGE_MIN , range_max : int = DEFAULT_PORT_RANGE_MAX , max_tries : int = DEFAULT_PORT_MAX_TRIES , search_type : SearchType = DEFAULT_PORT_SEARCH_TYPE , ) -> int : max_tries = min ( max_tries , range_max - range_min + 1 ) if search_type == SearchType . sequential : to_try = islice ( range ( range_min , range_max + 1 ), max_tries ) elif search_type == SearchType . random : to_try = random . sample ( range ( range_min , range_max + 1 ), max_tries ) else : msg = ( f \"Invalid search_type { search_type } . Available options are \" f \"[ { '|' . join ( level . value for level in SearchType ) } ].\" ) raise ValueError ( msg ) for port in to_try : if is_port_available ( port = port ): return port raise NoAvailablePortFound ( f \"Unable to find available port in range [ { range_min } , { range_max } ] with \" f \" { SearchType ( search_type ) . value } search in { max_tries } tries.\" ) is_port_available ( port ) Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Parameters: Name Type Description Default port int port to check. required Returns: Type Description bool bool: If that port is available (not in use). Source code in quickhttp/core.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def is_port_available ( port : int ) -> bool : \"\"\"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Args: port (int): port to check. Returns: bool: If that port is available (not in use). \"\"\" with closing ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM )) as sock : if sock . connect_ex (( \"127.0.0.1\" , port )) == 0 : # Successfull connection return False return True run_timed_http_server ( address , port , directory , time ) Start a HTTPServer for specified time. Parameters: Name Type Description Default address str Address to bind the server to. required port int Port to use. required directory Path Directory to serve. required time int Time to keep server alive for, in seconds. required Source code in quickhttp/core.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def run_timed_http_server ( address : str , port : int , directory : Path , time : int ): \"\"\"Start a [HTTPServer](https://docs.python.org/3/library/http.server.html) for specified time. Args: address (str): Address to bind the server to. port (int): Port to use. directory (Path): Directory to serve. time (int): Time to keep server alive for, in seconds. \"\"\" httpd = HTTPServer ( server_address = ( address , port ), RequestHandlerClass = SimpleHTTPRequestHandler ) with working_directory ( directory ): thread = Thread ( target = httpd . serve_forever , daemon = True ) thread . start () try : sleep ( time ) except KeyboardInterrupt : pass httpd . shutdown () working_directory ( directory ) Context manager that changes working directory and returns to previous on exit. Parameters: Name Type Description Default directory Path Directory to temporarily change to. required Source code in quickhttp/core.py 113 114 115 116 117 118 119 120 121 122 123 124 125 @contextmanager def working_directory ( directory : Path ): \"\"\"Context manager that changes working directory and returns to previous on exit. Args: directory (Path): Directory to temporarily change to. \"\"\" prev_cwd = Path . cwd () os . chdir ( directory ) try : yield finally : os . chdir ( prev_cwd )","title":"API Reference"},{"location":"api-reference/#api-reference","text":"Documentation for quickhttp.core module.","title":"API Reference"},{"location":"api-reference/#quickhttp.core.SearchType","text":"Available types of search for [find_available_port][quickhttp.core.find_available_port] Attributes: sequential: Search ports sequentially, starting with range_min. random: Search ports randomly within [range_min, range_max].","title":"SearchType"},{"location":"api-reference/#quickhttp.core.find_available_port","text":"Searches for an available port (not in use) on the local host. Parameters: Name Type Description Default range_min int Minimum of range to search. Defaults to 8000. 8000 range_max int Maximum of range to search. Defaults to 8999. 8999 max_tries int Maximum number of ports to check. Defaults to 50. 50 search_type SearchType Type of search. One of [sequential|random]. Defaults to sequential. 'sequential' Exceptions: Type Description ValueError If search_type is invalid. NoAvailablePortFound If no available ports found within max_tries. Returns: Type Description int int: An available port Source code in quickhttp/core.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def find_available_port ( range_min : int = DEFAULT_PORT_RANGE_MIN , range_max : int = DEFAULT_PORT_RANGE_MAX , max_tries : int = DEFAULT_PORT_MAX_TRIES , search_type : SearchType = DEFAULT_PORT_SEARCH_TYPE , ) -> int : max_tries = min ( max_tries , range_max - range_min + 1 ) if search_type == SearchType . sequential : to_try = islice ( range ( range_min , range_max + 1 ), max_tries ) elif search_type == SearchType . random : to_try = random . sample ( range ( range_min , range_max + 1 ), max_tries ) else : msg = ( f \"Invalid search_type { search_type } . Available options are \" f \"[ { '|' . join ( level . value for level in SearchType ) } ].\" ) raise ValueError ( msg ) for port in to_try : if is_port_available ( port = port ): return port raise NoAvailablePortFound ( f \"Unable to find available port in range [ { range_min } , { range_max } ] with \" f \" { SearchType ( search_type ) . value } search in { max_tries } tries.\" )","title":"find_available_port()"},{"location":"api-reference/#quickhttp.core.is_port_available","text":"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Parameters: Name Type Description Default port int port to check. required Returns: Type Description bool bool: If that port is available (not in use). Source code in quickhttp/core.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def is_port_available ( port : int ) -> bool : \"\"\"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Args: port (int): port to check. Returns: bool: If that port is available (not in use). \"\"\" with closing ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM )) as sock : if sock . connect_ex (( \"127.0.0.1\" , port )) == 0 : # Successfull connection return False return True","title":"is_port_available()"},{"location":"api-reference/#quickhttp.core.run_timed_http_server","text":"Start a HTTPServer for specified time. Parameters: Name Type Description Default address str Address to bind the server to. required port int Port to use. required directory Path Directory to serve. required time int Time to keep server alive for, in seconds. required Source code in quickhttp/core.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 def run_timed_http_server ( address : str , port : int , directory : Path , time : int ): \"\"\"Start a [HTTPServer](https://docs.python.org/3/library/http.server.html) for specified time. Args: address (str): Address to bind the server to. port (int): Port to use. directory (Path): Directory to serve. time (int): Time to keep server alive for, in seconds. \"\"\" httpd = HTTPServer ( server_address = ( address , port ), RequestHandlerClass = SimpleHTTPRequestHandler ) with working_directory ( directory ): thread = Thread ( target = httpd . serve_forever , daemon = True ) thread . start () try : sleep ( time ) except KeyboardInterrupt : pass httpd . shutdown ()","title":"run_timed_http_server()"},{"location":"api-reference/#quickhttp.core.working_directory","text":"Context manager that changes working directory and returns to previous on exit. Parameters: Name Type Description Default directory Path Directory to temporarily change to. required Source code in quickhttp/core.py 113 114 115 116 117 118 119 120 121 122 123 124 125 @contextmanager def working_directory ( directory : Path ): \"\"\"Context manager that changes working directory and returns to previous on exit. Args: directory (Path): Directory to temporarily change to. \"\"\" prev_cwd = Path . cwd () os . chdir ( directory ) try : yield finally : os . chdir ( prev_cwd )","title":"working_directory()"}]}