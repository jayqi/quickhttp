{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"quickhttp \u00b6 quickhttp is a lightweight CLI that wraps Python's http.server with automatic port-finding and automatic shutdown after a configurable idle duration. Features \u00b6 Automatically finds and uses an available port. Has a keep-alive time after which it will shut down automatically if no requests are received, in case you forget about it. More secure default of 127.0.0.1 ( localhost ) instead of 0.0.0.0 . Easier to type and autocomplete than python -m http.server . Installation \u00b6 You can get quickhttp from PyPI . I recommend using pipx to manage Python command-line programs: pipx install quickhttp You can also install normally using regular pip : pip install quickhttp Requires Python 3.6 or higher. Development Version \u00b6 To install the development version of this program, get it directly from GitHub. pipx install git+https://github.com/jayqi/quickhttp.git Documentation \u00b6 quickhttp --help Usage: quickhttp [OPTIONS] [DIRECTORY] Lightweight CLI that wraps Python's `http.server` with automatic port- finding and shutdown. Arguments: [DIRECTORY] Directory to serve. [default: .] Options: -t, --timeout TEXT Time to keep server alive for after most recent request. Accepts time expressions parsable by pytime parse, such as '10m' or '10:00'. [default: 10m] -b, --bind TEXT Address to bind server to. '127.0.0.1' (or 'localhost') will only be accessible from this computer. '0.0.0.0' is all interfaces (IP addresses) on this computer, meaning that it can be accessible by other computers at your IP address. [default: 127.0.0.1] -p, --port INTEGER Port to use. If None (default), will automatically search for an open port using the other port-related options. If specified, ignores other port-related options. --port-range-min INTEGER Minimum of range to search for an open port. [default: 8000] --port-range-max INTEGER Maximum of range to search for an open port. [default: 8999] --port-max-tries INTEGER Maximum number of ports to check. [default: 50] --port-search-type [sequential|random] Type of search to use. [default: sequential] --version Show version and exit. --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit. Why use quickhttp ? \u00b6 python -m http.server is a pain to type. quickhttp is shorter and can autocomplete. (But you can still do python -m quickhttp too if you really want to.) If you try starting python -m http.server and port 8000 is unavailable, you get OSError: [Errno 48] Address already in use . Then you have to choose another port and try again. quickhttp deals with ports automatically for you. quickhttp will automatically shutdown after the keep-alive time expires. This defaults to 10 minutes. I often start up an HTTP server to look at something, then open a new tab to continue doing things, and then I forget about the server. python -m http.server defaults to 0.0.0.0, which may make your server accessible to other people at your computer's IP address. This is a security vulnerability, but isn't necessarily obvious to people who just want to quickly serve some static files.","title":"Home"},{"location":"#quickhttp","text":"quickhttp is a lightweight CLI that wraps Python's http.server with automatic port-finding and automatic shutdown after a configurable idle duration.","title":"quickhttp"},{"location":"#features","text":"Automatically finds and uses an available port. Has a keep-alive time after which it will shut down automatically if no requests are received, in case you forget about it. More secure default of 127.0.0.1 ( localhost ) instead of 0.0.0.0 . Easier to type and autocomplete than python -m http.server .","title":"Features"},{"location":"#installation","text":"You can get quickhttp from PyPI . I recommend using pipx to manage Python command-line programs: pipx install quickhttp You can also install normally using regular pip : pip install quickhttp Requires Python 3.6 or higher.","title":"Installation"},{"location":"#development-version","text":"To install the development version of this program, get it directly from GitHub. pipx install git+https://github.com/jayqi/quickhttp.git","title":"Development Version"},{"location":"#documentation","text":"quickhttp --help Usage: quickhttp [OPTIONS] [DIRECTORY] Lightweight CLI that wraps Python's `http.server` with automatic port- finding and shutdown. Arguments: [DIRECTORY] Directory to serve. [default: .] Options: -t, --timeout TEXT Time to keep server alive for after most recent request. Accepts time expressions parsable by pytime parse, such as '10m' or '10:00'. [default: 10m] -b, --bind TEXT Address to bind server to. '127.0.0.1' (or 'localhost') will only be accessible from this computer. '0.0.0.0' is all interfaces (IP addresses) on this computer, meaning that it can be accessible by other computers at your IP address. [default: 127.0.0.1] -p, --port INTEGER Port to use. If None (default), will automatically search for an open port using the other port-related options. If specified, ignores other port-related options. --port-range-min INTEGER Minimum of range to search for an open port. [default: 8000] --port-range-max INTEGER Maximum of range to search for an open port. [default: 8999] --port-max-tries INTEGER Maximum number of ports to check. [default: 50] --port-search-type [sequential|random] Type of search to use. [default: sequential] --version Show version and exit. --install-completion [bash|zsh|fish|powershell|pwsh] Install completion for the specified shell. --show-completion [bash|zsh|fish|powershell|pwsh] Show completion for the specified shell, to copy it or customize the installation. --help Show this message and exit.","title":"Documentation"},{"location":"#why-use-quickhttp","text":"python -m http.server is a pain to type. quickhttp is shorter and can autocomplete. (But you can still do python -m quickhttp too if you really want to.) If you try starting python -m http.server and port 8000 is unavailable, you get OSError: [Errno 48] Address already in use . Then you have to choose another port and try again. quickhttp deals with ports automatically for you. quickhttp will automatically shutdown after the keep-alive time expires. This defaults to 10 minutes. I often start up an HTTP server to look at something, then open a new tab to continue doing things, and then I forget about the server. python -m http.server defaults to 0.0.0.0, which may make your server accessible to other people at your computer's IP address. This is a security vulnerability, but isn't necessarily obvious to people who just want to quickly serve some static files.","title":"Why use quickhttp?"},{"location":"changelog/","text":"Release Notes \u00b6 v1.0.0 - 2021-09-06 \u00b6 Changed module organization of package code to be more clear and explicit: Changed name of quickhttp.core to quickhttp.http_server . Changed name of quickhttp.quickhttp to quickhttp.cli . Added new quickhttp.exceptions module for all package custom exceptions: Added new base exception class QuickhttpException that all other exceptions from this package subclass. Added new exception class InvalidSearchTypeError . Changed name of NoAvailablePortFound to NoAvailablePortFoundError . It is now a subclass of QuickhttpException . v0.2.0 - 2020-11-21 \u00b6 Changed --time option name to --timeout . Changed timeout time to be from last request instead of from server startup. v0.1.0 - 2020-07-16 \u00b6 Initial release. :sparkles:","title":"Changelog"},{"location":"changelog/#release-notes","text":"","title":"Release Notes"},{"location":"changelog/#v100-2021-09-06","text":"Changed module organization of package code to be more clear and explicit: Changed name of quickhttp.core to quickhttp.http_server . Changed name of quickhttp.quickhttp to quickhttp.cli . Added new quickhttp.exceptions module for all package custom exceptions: Added new base exception class QuickhttpException that all other exceptions from this package subclass. Added new exception class InvalidSearchTypeError . Changed name of NoAvailablePortFound to NoAvailablePortFoundError . It is now a subclass of QuickhttpException .","title":"v1.0.0 - 2021-09-06"},{"location":"changelog/#v020-2020-11-21","text":"Changed --time option name to --timeout . Changed timeout time to be from last request instead of from server startup.","title":"v0.2.0 - 2020-11-21"},{"location":"changelog/#v010-2020-07-16","text":"Initial release. :sparkles:","title":"v0.1.0 - 2020-07-16"},{"location":"api-reference/exceptions/","text":"quickhttp.exceptions \u00b6 Documentation for quickhttp.exceptions module. Classes \u00b6 InvalidSearchTypeError \u00b6 NoAvailablePortFoundError \u00b6 QuickhttpException \u00b6 Base exception for all quickhttp custom exceptions.","title":"quickhttp.exceptions"},{"location":"api-reference/exceptions/#quickhttpexceptions","text":"Documentation for quickhttp.exceptions module.","title":"quickhttp.exceptions"},{"location":"api-reference/exceptions/#quickhttp.exceptions-classes","text":"","title":"Classes"},{"location":"api-reference/exceptions/#quickhttp.exceptions.InvalidSearchTypeError","text":"","title":"InvalidSearchTypeError"},{"location":"api-reference/exceptions/#quickhttp.exceptions.NoAvailablePortFoundError","text":"","title":"NoAvailablePortFoundError"},{"location":"api-reference/exceptions/#quickhttp.exceptions.QuickhttpException","text":"Base exception for all quickhttp custom exceptions.","title":"QuickhttpException"},{"location":"api-reference/http_server/","text":"quickhttp.http_server \u00b6 Documentation for quickhttp.http_server module. Classes \u00b6 DirectoryHTTPRequestHandler \u00b6 Subclass of http.server.SimpleHTTPRequestHandler that accepts a directory. Necessary because Python 3.6 doesn't support the directory argument added in Python 3.7. Methods \u00b6 translate_path ( self , path ) \u00b6 Translate a /-separated PATH to the local filename syntax. Components that mean special things to the local file system (e.g. drive or directory names) are ignored. (XXX They should probably be diagnosed.) Source code in quickhttp/http_server.py def translate_path ( self , path ): path = super () . translate_path ( path ) rel_path = Path ( path ) . relative_to ( Path . cwd ()) return self . directory / rel_path SearchType \u00b6 Enum. Available types of search for find_available_port . Attributes: Name Type Description sequential Search ports sequentially in ascending order, starting with range_min. random Search ports randomly within the interval [range_min, range_max]. TimedHTTPServer \u00b6 Subclass of http.server.HTTPServer that tracks timeout status. Methods \u00b6 handle_timeout ( self ) \u00b6 Called if no new request arrives within self.timeout. Source code in quickhttp/http_server.py def handle_timeout ( self ): \"\"\"Called if no new request arrives within self.timeout.\"\"\" self . timeout_reached = True Functions \u00b6 find_available_port ( range_min : int = 8000 , range_max : int = 8999 , max_tries : int = 50 , search_type : SearchType = < SearchType . sequential : 'sequential' > ) -> int \u00b6 Searches for an available port (not in use) on the local host. Parameters: Name Type Description Default range_min int Minimum of range to search. Defaults to 8000. 8000 range_max int Maximum of range to search. Defaults to 8999. 8999 max_tries int Maximum number of ports to check. Defaults to 50. 50 search_type SearchType Type of search. One of [sequential|random]. Defaults to sequential. <SearchType.sequential: 'sequential'> Exceptions: Type Description quickhttp.exceptions.InvalidSearchTypeError If search_type is invalid. quickhttp.exceptions.NoAvailablePortFoundError If no available ports found within max_tries. Returns: Type Description int int: An available port. Source code in quickhttp/http_server.py def find_available_port ( range_min : int = DEFAULT_PORT_RANGE_MIN , range_max : int = DEFAULT_PORT_RANGE_MAX , max_tries : int = DEFAULT_PORT_MAX_TRIES , search_type : SearchType = DEFAULT_PORT_SEARCH_TYPE , ) -> int : max_tries = min ( max_tries , range_max - range_min + 1 ) to_try : Iterable [ int ] if search_type == SearchType . sequential : to_try = islice ( range ( range_min , range_max + 1 ), max_tries ) elif search_type == SearchType . random : to_try = random . sample ( range ( range_min , range_max + 1 ), max_tries ) else : msg = ( f \"Invalid search_type { search_type } . Available options are \" f \"[ { '|' . join ( level . value for level in SearchType ) } ].\" ) raise exceptions . InvalidSearchTypeError ( msg ) for port in to_try : if is_port_available ( port = port ): return port raise exceptions . NoAvailablePortFoundError ( f \"Unable to find available port in range [ { range_min } , { range_max } ] with \" f \" { SearchType ( search_type ) . value } search in { max_tries } tries.\" ) is_port_available ( port : int ) -> bool \u00b6 Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Parameters: Name Type Description Default port int port to check. required Returns: Type Description bool bool: If that port is available (not in use). Source code in quickhttp/http_server.py def is_port_available ( port : int ) -> bool : \"\"\"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Args: port (int): port to check. Returns: bool: If that port is available (not in use). \"\"\" with closing ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM )) as sock : if sock . connect_ex (( \"127.0.0.1\" , port )) == 0 : # Successfull connection return False return True run_timed_http_server ( address : str , port : int , directory : Union [ str , os . PathLike ], timeout : int ) \u00b6 Start a TimedHTTPServer with specified timeout. Parameters: Name Type Description Default address str Address to bind the server to. required port int Port to use. required directory Union[str, os.PathLike] Directory to serve. required timeout int Time to keep server alive for, in seconds. required Source code in quickhttp/http_server.py def run_timed_http_server ( address : str , port : int , directory : Union [ str , os . PathLike ], timeout : int ): \"\"\"Start a [TimedHTTPServer][quickhttp.http_server.TimedHTTPServer] with specified timeout. Args: address (str): Address to bind the server to. port (int): Port to use. directory (Union[str, os.PathLike]): Directory to serve. timeout (int): Time to keep server alive for, in seconds. \"\"\" if sys . version_info [: 2 ] == ( 3 , 6 ): handler = partial ( DirectoryHTTPRequestHandler , directory = str ( directory )) else : handler = partial ( SimpleHTTPRequestHandler , directory = str ( directory )) with TimedHTTPServer ( server_address = ( address , port ), RequestHandlerClass = handler , timeout = timeout ) as httpd : try : while not httpd . timeout_reached : # type: ignore httpd . handle_request () typer . echo ( \"Timeout reached.\" ) except KeyboardInterrupt : typer . echo ( \" KeyboardInterrupt received.\" )","title":"quickhttp.http_server"},{"location":"api-reference/http_server/#quickhttphttp_server","text":"Documentation for quickhttp.http_server module.","title":"quickhttp.http_server"},{"location":"api-reference/http_server/#quickhttp.http_server-classes","text":"","title":"Classes"},{"location":"api-reference/http_server/#quickhttp.http_server.DirectoryHTTPRequestHandler","text":"Subclass of http.server.SimpleHTTPRequestHandler that accepts a directory. Necessary because Python 3.6 doesn't support the directory argument added in Python 3.7.","title":"DirectoryHTTPRequestHandler"},{"location":"api-reference/http_server/#quickhttp.http_server.SearchType","text":"Enum. Available types of search for find_available_port . Attributes: Name Type Description sequential Search ports sequentially in ascending order, starting with range_min. random Search ports randomly within the interval [range_min, range_max].","title":"SearchType"},{"location":"api-reference/http_server/#quickhttp.http_server.TimedHTTPServer","text":"Subclass of http.server.HTTPServer that tracks timeout status.","title":"TimedHTTPServer"},{"location":"api-reference/http_server/#quickhttp.http_server-functions","text":"","title":"Functions"},{"location":"api-reference/http_server/#quickhttp.http_server.find_available_port","text":"Searches for an available port (not in use) on the local host. Parameters: Name Type Description Default range_min int Minimum of range to search. Defaults to 8000. 8000 range_max int Maximum of range to search. Defaults to 8999. 8999 max_tries int Maximum number of ports to check. Defaults to 50. 50 search_type SearchType Type of search. One of [sequential|random]. Defaults to sequential. <SearchType.sequential: 'sequential'> Exceptions: Type Description quickhttp.exceptions.InvalidSearchTypeError If search_type is invalid. quickhttp.exceptions.NoAvailablePortFoundError If no available ports found within max_tries. Returns: Type Description int int: An available port. Source code in quickhttp/http_server.py def find_available_port ( range_min : int = DEFAULT_PORT_RANGE_MIN , range_max : int = DEFAULT_PORT_RANGE_MAX , max_tries : int = DEFAULT_PORT_MAX_TRIES , search_type : SearchType = DEFAULT_PORT_SEARCH_TYPE , ) -> int : max_tries = min ( max_tries , range_max - range_min + 1 ) to_try : Iterable [ int ] if search_type == SearchType . sequential : to_try = islice ( range ( range_min , range_max + 1 ), max_tries ) elif search_type == SearchType . random : to_try = random . sample ( range ( range_min , range_max + 1 ), max_tries ) else : msg = ( f \"Invalid search_type { search_type } . Available options are \" f \"[ { '|' . join ( level . value for level in SearchType ) } ].\" ) raise exceptions . InvalidSearchTypeError ( msg ) for port in to_try : if is_port_available ( port = port ): return port raise exceptions . NoAvailablePortFoundError ( f \"Unable to find available port in range [ { range_min } , { range_max } ] with \" f \" { SearchType ( search_type ) . value } search in { max_tries } tries.\" )","title":"find_available_port()"},{"location":"api-reference/http_server/#quickhttp.http_server.is_port_available","text":"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Parameters: Name Type Description Default port int port to check. required Returns: Type Description bool bool: If that port is available (not in use). Source code in quickhttp/http_server.py def is_port_available ( port : int ) -> bool : \"\"\"Check if port is available (not in use) on the local host. This is determined by attemping to create a socket connection with that port. If the connection is successful, that means something is using the port. Args: port (int): port to check. Returns: bool: If that port is available (not in use). \"\"\" with closing ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM )) as sock : if sock . connect_ex (( \"127.0.0.1\" , port )) == 0 : # Successfull connection return False return True","title":"is_port_available()"},{"location":"api-reference/http_server/#quickhttp.http_server.run_timed_http_server","text":"Start a TimedHTTPServer with specified timeout. Parameters: Name Type Description Default address str Address to bind the server to. required port int Port to use. required directory Union[str, os.PathLike] Directory to serve. required timeout int Time to keep server alive for, in seconds. required Source code in quickhttp/http_server.py def run_timed_http_server ( address : str , port : int , directory : Union [ str , os . PathLike ], timeout : int ): \"\"\"Start a [TimedHTTPServer][quickhttp.http_server.TimedHTTPServer] with specified timeout. Args: address (str): Address to bind the server to. port (int): Port to use. directory (Union[str, os.PathLike]): Directory to serve. timeout (int): Time to keep server alive for, in seconds. \"\"\" if sys . version_info [: 2 ] == ( 3 , 6 ): handler = partial ( DirectoryHTTPRequestHandler , directory = str ( directory )) else : handler = partial ( SimpleHTTPRequestHandler , directory = str ( directory )) with TimedHTTPServer ( server_address = ( address , port ), RequestHandlerClass = handler , timeout = timeout ) as httpd : try : while not httpd . timeout_reached : # type: ignore httpd . handle_request () typer . echo ( \"Timeout reached.\" ) except KeyboardInterrupt : typer . echo ( \" KeyboardInterrupt received.\" )","title":"run_timed_http_server()"}]}